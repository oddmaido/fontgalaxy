<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Font Galaxy</title>
    <style>
        @font-face {
            font-family: 'IBM Plex Mono';
            src: url('/static/IBMPlexMono-Medium.ttf') format('truetype');
            font-weight: 500;
        }
        @font-face {
            font-family: 'Bianzhidai';
            src: url('/static/bianzhidai-noBG-Base.otf') format('opentype');
            font-weight: normal;
        }
        @font-face {
            font-family: 'Bianzhidai Base';
            src: url('/static/bianzhidai-Base-new.otf') format('opentype');
            font-weight: normal;
        }
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            background: #000;
            color: #fff;
            font-family: 'IBM Plex Mono', monospace;
            overflow: hidden;
            text-transform: uppercase;
            letter-spacing: 0.05em;
        }
        #container { width: 100vw; height: 100vh; }

        /* Top Bar */
        #top-bar {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            display: flex;
            justify-content: space-between;
            padding: 20px 30px;
            font-size: 11px;
            pointer-events: none;
        }
        #top-bar > div {
            display: flex;
            align-items: center;
            gap: 10px;
        }
        #top-bar .indicator {
            width: 6px;
            height: 6px;
            background: rgba(255, 255, 255, 0.8);
        }
        #top-bar span:not(.indicator) {
            color: #fff;
        }


        /* CSS Variables for consistent styling */
        :root {
            --hud-border: 1px;
            --hud-line: rgba(255, 255, 255, 0.35);
            --hud-text: rgba(255, 255, 255, 1);
            --hud-text-muted: rgba(255, 255, 255, 1);
            --hud-node: rgba(255, 255, 255, 0.95);
            --pad: 16px;
            --pad-sm: 10px;
            --node-size: 7px;
            --sidebar-w: clamp(280px, 22vw, 340px);
        }

        /* Corner Node Squares - FILLED solid white */
        .corner-node {
            position: absolute;
            width: var(--node-size);
            height: var(--node-size);
            background: var(--hud-node);
            pointer-events: none;
            z-index: 10;
        }
        .corner-node.tl { top: 0; left: 0; transform: translate(-50%, -50%); }
        .corner-node.tr { top: 0; right: 0; transform: translate(50%, -50%); }
        .corner-node.bl { bottom: 0; left: 0; transform: translate(-50%, 50%); }
        .corner-node.br { bottom: 0; right: 0; transform: translate(50%, 50%); }

        /* Main UI Container - CSS Grid for perfect alignment */
        #ui-container {
            position: absolute;
            bottom: 30px;
            left: 30px;
            right: 30px;
            display: grid;
            grid-template-columns: 1fr var(--sidebar-w);
            align-items: end;
        }

        /* Bottom Panel - uses CSS Grid for column widths */
        #bottom-panel {
            border: var(--hud-border) solid var(--hud-line);
            border-right: none; /* Sidebar draws the shared border */
            display: grid;
            grid-template-columns: 140px 320px minmax(280px, 1fr) 230px;
            position: relative;
        }
        #bottom-panel h3 {
            font-family: 'Bianzhidai', monospace;
            font-size: 11px;
            font-weight: normal;
            margin-bottom: 8px;
            letter-spacing: 0.1em;
            color: var(--hud-text-muted);
        }

        /* Font Galaxy Title Section */
        #title-section {
            padding: var(--pad-sm);
            border-right: var(--hud-border) solid var(--hud-line);
            display: flex;
            align-items: center;
            justify-content: center;
            position: relative;
        }
        /* Corner nodes at title section right edge - FILLED */
        #title-section::before,
        #title-section::after {
            content: '';
            position: absolute;
            width: var(--node-size);
            height: var(--node-size);
            background: var(--hud-node);
            right: 0;
        }
        #title-section::before { top: 0; transform: translate(50%, -50%); }
        #title-section::after { bottom: 0; transform: translate(50%, 50%); }
        #title-section .title {
            font-family: 'Bianzhidai', monospace;
            font-size: 12px;
            letter-spacing: 0.12em;
            color: #fff;
            white-space: nowrap;
        }

        /* Controls Section */
        #controls-section {
            padding: var(--pad-sm);
            border-right: var(--hud-border) solid var(--hud-line);
            position: relative;
        }
        /* Corner nodes at controls section right edge - FILLED */
        #controls-section::before,
        #controls-section::after {
            content: '';
            position: absolute;
            width: var(--node-size);
            height: var(--node-size);
            background: var(--hud-node);
            right: 0;
        }
        #controls-section::before { top: 0; transform: translate(50%, -50%); }
        #controls-section::after { bottom: 0; transform: translate(50%, 50%); }

        /* Controls Grid - layout only */
        #controls-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            grid-template-rows: 1fr 1fr;
            gap: 0;
            font-size: 9px;
            position: relative;
            height: 100%;
        }
        /* Vertical divider - extends to outer frame */
        #controls-grid::before {
            content: '';
            position: absolute;
            top: calc(-1 * var(--pad-sm));
            bottom: calc(-1 * var(--pad-sm));
            left: 50%;
            width: 1px;
            background: var(--hud-line);
            transform: translateX(-0.5px);
        }
        /* Horizontal divider - extends to outer frame */
        #controls-grid::after {
            content: '';
            position: absolute;
            left: calc(-1 * var(--pad-sm));
            right: calc(-1 * var(--pad-sm));
            top: 50%;
            height: 1px;
            background: var(--hud-line);
            transform: translateY(-0.5px);
        }
        /* Grid cells - padding only, no borders */
        #controls-grid .control-item {
            padding: 8px 12px;
        }

        .control-key {
            font-family: 'Bianzhidai Base', monospace;
            color: #fff;
            margin-bottom: 4px;
            font-size: 10px;
            letter-spacing: 0.08em;
        }
        .control-action {
            font-family: 'IBM Plex Mono', monospace;
            color: #fff;
            font-size: 10px;
        }

        /* Context Section - widest column */
        #context-section {
            padding: var(--pad);
            border-right: var(--hud-border) solid var(--hud-line);
            position: relative;
        }
        /* Corner nodes at context section right edge - FILLED */
        #context-section::before,
        #context-section::after {
            content: '';
            position: absolute;
            width: var(--node-size);
            height: var(--node-size);
            background: var(--hud-node);
            right: 0;
        }
        #context-section::before { top: 0; transform: translate(50%, -50%); }
        #context-section::after { bottom: 0; transform: translate(50%, 50%); }
        #context-section p {
            font-family: 'IBM Plex Mono', monospace;
            font-size: 9px;
            line-height: 1.65;
            color: var(--hud-text-muted);
            text-transform: uppercase;
        }

        /* About Section */
        #about-section {
            padding: var(--pad);
            position: relative;
        }
        /* Corner nodes at shared edge with sidebar */
        #about-section::before,
        #about-section::after {
            content: '';
            position: absolute;
            width: var(--node-size);
            height: var(--node-size);
            background: var(--hud-node);
            right: 0;
        }
        #about-section::before { top: 0; transform: translate(50%, -50%); }
        #about-section::after { bottom: 0; transform: translate(50%, 50%); }
        #about-section p {
            font-family: 'IBM Plex Mono', monospace;
            font-size: 9px;
            line-height: 1.65;
            color: var(--hud-text-muted);
        }

        /* Right Panel - Blended Fonts (fixed width, stable layout) */
        #font-panel {
            width: var(--sidebar-w);
            border: var(--hud-border) solid var(--hud-line);
            display: flex;
            flex-direction: column;
            position: relative;
        }
        #font-panel h3 {
            font-family: 'Bianzhidai', monospace;
            font-size: 11px;
            font-weight: normal;
            margin-bottom: var(--pad-sm);
            letter-spacing: 0.1em;
            color: var(--hud-text-muted);
        }
        /* Apply custom font to entire blended fonts column */
        #font-panel {
            font-family: 'Bianzhidai', monospace;
        }
        #preview-section {
            padding: var(--pad);
        }
        #preview-image {
            width: 100%;
            height: auto;
            background: #fff;
            image-rendering: pixelated;
            display: block;
        }
        #neighbors-section {
            padding: var(--pad);
        }
        /* Fixed-width grid for stable list alignment */
        #neighbors {
            font-size: 9px;
            display: flex;
            flex-direction: column;
            gap: 0;
        }
        .neighbor {
            display: grid;
            grid-template-columns: 1fr 56px;
            align-items: baseline;
            padding: 7px 0;
            gap: 8px;
        }
        .neighbor:not(:last-child) {
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
        }
        .neighbor:first-child {
            padding-top: 0;
        }
        .neighbor:last-child {
            padding-bottom: 0;
        }
        .neighbor-name {
            font-family: 'Bianzhidai', monospace;
            color: #fff;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            min-width: 0;
        }
        .neighbor-weight {
            font-family: 'Bianzhidai', monospace;
            color: #fff;
            font-variant-numeric: tabular-nums;
            text-align: right;
            flex-shrink: 0;
        }

        /* Specimen Modal */
        #modal-overlay {
            display: none;
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.85);
            z-index: 999;
        }
        #specimen-modal {
            display: none;
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: #000;
            padding: 25px;
            border: 1px solid rgba(255, 255, 255, 0.3);
            z-index: 1000;
            max-width: 90vw;
            max-height: 90vh;
        }
        #specimen-modal h3 {
            font-family: 'Bianzhidai', monospace;
            font-size: 12px;
            font-weight: 500;
            margin: 0 0 15px 0;
            letter-spacing: 0.1em;
        }
        #specimen-modal img {
            max-width: 100%;
            max-height: 70vh;
            background: #111;
            border: 1px solid rgba(255, 255, 255, 0.2);
            image-rendering: pixelated;
        }
        #specimen-modal .close-btn {
            position: absolute;
            top: 15px;
            right: 20px;
            color: rgba(255, 255, 255, 0.5);
            font-size: 20px;
            cursor: pointer;
        }
        #specimen-modal .close-btn:hover { color: #fff; }

        /* Loading */
        #loading {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            text-align: center;
        }
        #loading h2 {
            font-size: 14px;
            font-weight: 500;
            letter-spacing: 0.15em;
            margin-bottom: 30px;
        }
        #loading-bar {
            width: 200px;
            height: 1px;
            background: rgba(255, 255, 255, 0.2);
            margin: 0 auto 15px;
        }
        #loading-progress {
            height: 100%;
            background: #fff;
            width: 0%;
            transition: width 0.3s;
        }
        #loading-status {
            font-size: 10px;
            color: rgba(255, 255, 255, 0.5);
        }

        /* Void Warning */
        #void-warning {
            display: none;
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            text-align: center;
            pointer-events: none;
            z-index: 100;
        }
        #void-warning .message,
        #void-warning .hint {
            pointer-events: none;
        }
        #void-warning .message {
            font-family: 'Bianzhidai', monospace;
            font-size: 14px;
            letter-spacing: 0.15em;
            color: rgba(255, 255, 255, 0.8);
            margin-bottom: 15px;
        }
        #void-warning .hint {
            font-family: 'IBM Plex Mono', monospace;
            font-size: 11px;
            color: rgba(255, 255, 255, 0.5);
            letter-spacing: 0.1em;
        }
        #void-warning .key {
            font-family: 'Bianzhidai Base', monospace;
            color: #fff;
            font-size: 13px;
        }
        #return-btn {
            margin-top: 20px;
            padding: 12px 30px;
            font-family: 'Bianzhidai', monospace;
            font-size: 11px;
            letter-spacing: 0.1em;
            background: transparent;
            border: 1px solid rgba(255, 255, 255, 0.5);
            color: #fff;
            cursor: pointer;
            pointer-events: auto;
            transition: all 0.2s;
        }
        #return-btn:hover {
            background: rgba(255, 255, 255, 0.1);
            border-color: #fff;
        }
    </style>
</head>
<body>
    <div id="container"></div>

    <div id="loading">
        <h2>FONT SPACE</h2>
        <div id="loading-bar"><div id="loading-progress"></div></div>
        <div id="loading-status">LOADING UNIVERSE...</div>
    </div>

    <div id="void-warning">
        <div class="message">YOU ARE IN THE VOID</div>
        <div class="hint">PRESS <span class="key">R</span> OR CLICK BELOW TO RETURN</div>
        <button id="return-btn" onclick="resetToCenter()">RETURN TO CENTER</button>
    </div>

    <div id="top-bar" style="display: none;">
        <div><span class="indicator"></span><span id="position">POSITION (0, 0, 0)</span></div>
        <div><span class="indicator"></span><span id="speed-display">SPEED: 50%</span></div>
        <div><span class="indicator"></span><span id="stars-count">STARS: 0</span></div>
    </div>


    <div id="ui-container" style="display: none;">
        <div id="bottom-panel">
            <!-- Corner nodes for bottom panel -->
            <span class="corner-node tl"></span>
            <span class="corner-node bl"></span>

            <div id="title-section">
                <div class="title">FONT SPACE</div>
            </div>

            <div id="controls-section">
                <div id="controls-grid">
                    <div class="control-item">
                        <div class="control-key">W A S D /////</div>
                        <div class="control-action">MOVE</div>
                    </div>
                    <div class="control-item">
                        <div class="control-key">ARROWS /////</div>
                        <div class="control-action">ROTATE</div>
                    </div>
                    <div class="control-item">
                        <div class="control-key">SCROLL /////</div>
                        <div class="control-action">SPEED</div>
                    </div>
                    <div class="control-item">
                        <div class="control-key">CLICK //////</div>
                        <div class="control-action">SELECT</div>
                    </div>
                </div>
            </div>

            <div id="context-section">
                <h3>CONTEXT</h3>
                <p>The project is an interactive typographic space where fonts are translated into a navigable galaxy. Each typeface exists as a point in space, defined by its visual characteristics. By moving through this environment, users explore typography not as static text, but as a system of relationships, distances, and transformations. Fonts can be selected, compared, and morphed into one another, revealing typography as a fluid, computational medium rather than a fixed form.</p>
            </div>

            <div id="about-section">
                <h3>ABOUT</h3>
                <p>PROJECT BY MAI DO<br>IG: @ODDMAIDO<br>DEVELOPED @BAUHAUS.TYPOGRAPHY</p>
            </div>
        </div>

        <div id="font-panel">
            <!-- Corner nodes for font panel -->
            <span class="corner-node tl"></span>
            <span class="corner-node tr"></span>
            <span class="corner-node br"></span>

            <div id="preview-section">
                <h3>BLENDED FONTS</h3>
                <img id="preview-image" src="" alt="Font Preview">
            </div>
            <div id="neighbors-section">
                <div id="neighbors"></div>
            </div>
        </div>
    </div>

    <div id="modal-overlay"></div>
    <div id="specimen-modal">
        <span class="close-btn">&times;</span>
        <h3 id="specimen-name">FONT NAME</h3>
        <img id="specimen-image" src="" alt="Font Specimen">
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        // Three.js setup
        const container = document.getElementById('container');
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x000000);
        scene.fog = new THREE.FogExp2(0x000000, 0.08);

        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(window.devicePixelRatio);
        container.appendChild(renderer.domElement);

        // State
        const state = {
            position: new THREE.Vector3(0, 0, 0),
            velocity: new THREE.Vector3(0, 0, 0),
            rotation: { x: 0, y: 0 },
            speed: 0.05,
            friction: 0.85,
            keys: {},
            stars: [],
            starMesh: null,
            bounds: null,
            locked: false,
            lastPreviewPos: null,
            previewCooldown: 0,
        };

        // Input
        document.addEventListener('keydown', e => state.keys[e.code] = true);
        document.addEventListener('keyup', e => state.keys[e.code] = false);

        // Mouse state
        state.modalOpen = false;

        let mouseX = 0;
        let mouseY = 0;
        let prevMouseX = 0;
        let prevMouseY = 0;
        let isMouseDown = false;
        let mouseDownX = 0;
        let mouseDownY = 0;
        let totalDragDistance = 0; // Track total drag distance

        // Track if mouse is inside the window
        let mouseInWindow = true;

        // Track mouse position
        document.addEventListener('mousemove', (e) => {
            prevMouseX = mouseX;
            prevMouseY = mouseY;
            mouseX = e.clientX;
            mouseY = e.clientY;
            mouseInWindow = true;

            // Update state for hover labels
            state.lastMouseX = mouseX;
            state.lastMouseY = mouseY;

            // Track drag distance when mouse is down
            if (isMouseDown) {
                const dx = mouseX - prevMouseX;
                const dy = mouseY - prevMouseY;
                totalDragDistance += Math.abs(dx) + Math.abs(dy);
            }
        });

        // Stop rotation when mouse leaves the window
        document.addEventListener('mouseleave', () => {
            mouseInWindow = false;
        });

        // Mouse down - enable dragging from anywhere
        document.addEventListener('mousedown', (e) => {
            if (e.button === 0) {
                // Only block if clicking on modal
                const target = e.target;
                const isModalClick = target.closest('#specimen-modal') ||
                                     target.closest('#modal-overlay');

                if (!isModalClick) {
                    isMouseDown = true;
                    mouseDownX = e.clientX;
                    mouseDownY = e.clientY;
                    totalDragDistance = 0; // Reset drag distance
                }
            }
        });

        // Mouse up - just reset the flag
        document.addEventListener('mouseup', (e) => {
            if (e.button === 0) {
                isMouseDown = false;
            }
        });

        // Use click event for selection - on document to catch all clicks
        document.addEventListener('click', (e) => {
            // Skip if clicking on modal elements
            const target = e.target;
            const isModalClick = target.closest('#specimen-modal') ||
                                 target.closest('#modal-overlay') ||
                                 target.closest('#return-btn') ||
                                 target.closest('#loading');

            if (isModalClick) return;

            // Force close modal if it's open
            if (state.modalOpen) {
                closeSpecimenModal();
                return;
            }

            // Select font at click position
            selectFontAtPosition(e.clientX, e.clientY);
        });

        // Modal handlers
        document.getElementById('modal-overlay').addEventListener('click', closeSpecimenModal);
        document.querySelector('#specimen-modal .close-btn').addEventListener('click', closeSpecimenModal);
        document.addEventListener('keydown', (e) => {
            if (e.key === 'Escape' || e.key === 'q' || e.key === 'Q') closeSpecimenModal();
        });

        function closeSpecimenModal() {
            document.getElementById('specimen-modal').style.display = 'none';
            document.getElementById('modal-overlay').style.display = 'none';
            state.modalOpen = false;
            state.hasMoved = false;
            totalDragDistance = 0;
        }

        function resetToCenter() {
            if (state.bounds) {
                state.position.set(
                    (state.bounds.min_x + state.bounds.max_x) / 2,
                    (state.bounds.min_y + state.bounds.max_y) / 2,
                    (state.bounds.min_z + state.bounds.max_z) / 2
                );
                state.velocity.set(0, 0, 0);
                state.rotation.x = 0;
                state.rotation.y = 0;
                document.getElementById('void-warning').style.display = 'none';
            }
        }

        async function showSpecimen(star) {
            state.modalOpen = true;

            document.getElementById('specimen-name').textContent = star.name;
            document.getElementById('specimen-modal').style.display = 'block';
            document.getElementById('modal-overlay').style.display = 'block';

            try {
                const res = await fetch(`/api/font_grid/${star.id}`);
                if (res.ok) {
                    const data = await res.json();
                    if (data.image) {
                        document.getElementById('specimen-image').src = `data:image/png;base64,${data.image}`;
                        return;
                    }
                }
                document.getElementById('specimen-image').src = '';
                document.getElementById('specimen-image').alt = 'Font specimen not available';
            } catch (e) {
                document.getElementById('specimen-image').src = '';
                document.getElementById('specimen-image').alt = 'Font specimen not available';
            }
        }

        function selectFontAtPosition(clickX, clickY) {
            if (!state.stars || state.stars.length === 0) return;

            let bestStar = null;
            let bestScreenDist = Infinity;

            for (const star of state.stars) {
                const pos = new THREE.Vector3(star.x * SCALE, star.y * SCALE, star.z * SCALE);
                pos.project(camera);

                if (pos.z > 1) continue;

                const screenX = (pos.x * 0.5 + 0.5) * window.innerWidth;
                const screenY = (-pos.y * 0.5 + 0.5) * window.innerHeight;

                const screenDist = Math.sqrt(
                    (screenX - clickX) ** 2 +
                    (screenY - clickY) ** 2
                );

                if (screenDist < bestScreenDist) {
                    bestScreenDist = screenDist;
                    bestStar = star;
                }
            }

            if (bestStar) {
                showSpecimen(bestStar);
            }
        }

        document.addEventListener('wheel', e => {
            state.speed = Math.max(0.01, Math.min(0.5, state.speed * (e.deltaY > 0 ? 0.85 : 1.15)));
        });

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        const SCALE = 3.0;

        function createDotTexture() {
            const canvas = document.createElement('canvas');
            canvas.width = 64;
            canvas.height = 64;
            const ctx = canvas.getContext('2d');
            ctx.clearRect(0, 0, 64, 64);
            ctx.beginPath();
            ctx.arc(32, 32, 28, 0, Math.PI * 2);
            ctx.fillStyle = 'white';
            ctx.fill();
            return new THREE.CanvasTexture(canvas);
        }

        function createStars(starsData) {
            const maxStars = 15000;
            let displayStars = starsData;
            if (starsData.length > maxStars) {
                displayStars = [];
                const step = Math.ceil(starsData.length / maxStars);
                for (let i = 0; i < starsData.length; i += step) {
                    displayStars.push(starsData[i]);
                }
            }
            state.displayStars = displayStars;

            const geometry = new THREE.BufferGeometry();
            const positions = new Float32Array(displayStars.length * 3);
            const colors = new Float32Array(displayStars.length * 3);

            for (let i = 0; i < displayStars.length; i++) {
                const star = displayStars[i];
                positions[i * 3] = star.x * SCALE;
                positions[i * 3 + 1] = star.y * SCALE;
                positions[i * 3 + 2] = star.z * SCALE;

                const brightness = 0.4 + Math.random() * 0.2;
                colors[i * 3] = brightness;
                colors[i * 3 + 1] = brightness;
                colors[i * 3 + 2] = brightness;
            }

            geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));

            const dotTexture = createDotTexture();
            const material = new THREE.PointsMaterial({
                size: 0.12,
                map: dotTexture,
                vertexColors: true,
                transparent: true,
                alphaTest: 0.5,
                opacity: 0.8,
                sizeAttenuation: true,
            });

            state.starMesh = new THREE.Points(geometry, material);
            scene.add(state.starMesh);

            // Active font spheres
            state.activeSphereMeshes = [];
            const sphereGeometry = new THREE.SphereGeometry(0.02, 12, 12);
            const sphereMaterial = new THREE.MeshBasicMaterial({ color: 0xffffff });

            for (let i = 0; i < 5; i++) {
                const sphere = new THREE.Mesh(sphereGeometry, sphereMaterial);
                sphere.visible = false;
                scene.add(sphere);
                state.activeSphereMeshes.push(sphere);
            }
        }

        function updateActiveStars(neighbors) {
            if (!state.activeSphereMeshes || !neighbors) return;

            for (let i = 0; i < 5; i++) {
                const sphere = state.activeSphereMeshes[i];
                if (i < neighbors.length) {
                    const n = neighbors[i];
                    sphere.position.set(n.x * SCALE, n.y * SCALE, n.z * SCALE);
                    sphere.visible = true;
                } else {
                    sphere.visible = false;
                }
            }
            state.activeNeighbors = neighbors;
        }

        function createLabels() {
            state.labelContainer = document.createElement('div');
            state.labelContainer.style.cssText = 'position:absolute;top:0;left:0;pointer-events:none;';
            document.body.appendChild(state.labelContainer);
            state.labels = [];

            for (let i = 0; i < 5; i++) {
                const label = document.createElement('div');
                label.style.cssText = `
                    position: absolute;
                    color: rgba(255, 255, 255, 0.8);
                    font-size: 10px;
                    font-family: 'IBM Plex Mono', monospace;
                    text-transform: uppercase;
                    letter-spacing: 0.05em;
                    text-shadow: 0 0 4px #000, 0 0 2px #000;
                    white-space: nowrap;
                    transform: translate(-50%, -100%);
                    pointer-events: none;
                `;
                state.labelContainer.appendChild(label);
                state.labels.push(label);
            }

            state.proximityLabel = document.createElement('div');
            state.proximityLabel.style.cssText = `
                position: absolute;
                color: #ffffff;
                font-size: 11px;
                font-family: 'IBM Plex Mono', monospace;
                text-transform: uppercase;
                letter-spacing: 0.05em;
                text-shadow: 0 0 6px #000, 0 0 3px #000;
                white-space: nowrap;
                transform: translate(-50%, -100%);
                display: none;
                pointer-events: none;
            `;
            state.labelContainer.appendChild(state.proximityLabel);
        }

        function updateProximityLabel() {
            // Check ALL stars for hover labels
            if (!state.stars || state.stars.length === 0 || !state.proximityLabel) return;

            let bestStar = null;
            let bestDist = 100; // Hover detection radius in pixels (increased)

            // Use mouse position instead of screen center
            const mouseX = state.lastMouseX || window.innerWidth / 2;
            const mouseY = state.lastMouseY || window.innerHeight / 2;

            // Check all stars in the full dataset
            for (const star of state.stars) {
                const pos = new THREE.Vector3(star.x * SCALE, star.y * SCALE, star.z * SCALE);
                pos.project(camera);

                if (pos.z >= 1) continue;

                const screenX = (pos.x * 0.5 + 0.5) * window.innerWidth;
                const screenY = (-pos.y * 0.5 + 0.5) * window.innerHeight;

                const screenDist = Math.sqrt(
                    (screenX - mouseX) ** 2 +
                    (screenY - mouseY) ** 2
                );

                if (screenDist < bestDist) {
                    bestDist = screenDist;
                    bestStar = { star, screenX, screenY };
                }
            }

            if (bestStar) {
                state.proximityLabel.style.left = bestStar.screenX + 'px';
                state.proximityLabel.style.top = (bestStar.screenY - 15) + 'px';
                state.proximityLabel.textContent = bestStar.star.name;
                state.proximityLabel.style.display = 'block';
            } else {
                state.proximityLabel.style.display = 'none';
            }
        }

        function updateLabels() {
            if (!state.activeNeighbors || !state.labels) return;

            for (let i = 0; i < 5; i++) {
                const label = state.labels[i];
                if (i < state.activeNeighbors.length) {
                    const n = state.activeNeighbors[i];
                    const pos = new THREE.Vector3(n.x * SCALE, n.y * SCALE, n.z * SCALE);
                    pos.project(camera);

                    const x = (pos.x * 0.5 + 0.5) * window.innerWidth;
                    const y = (-pos.y * 0.5 + 0.5) * window.innerHeight;

                    if (pos.z < 1) {
                        label.style.left = x + 'px';
                        label.style.top = (y - 10) + 'px';
                        label.textContent = n.name;
                        label.style.display = 'block';
                    } else {
                        label.style.display = 'none';
                    }
                } else {
                    label.style.display = 'none';
                }
            }
        }

        function update(dt) {
            const forward = new THREE.Vector3(0, 0, -1);
            const right = new THREE.Vector3(1, 0, 0);

            forward.applyEuler(new THREE.Euler(state.rotation.x, state.rotation.y, 0, 'YXZ'));
            right.applyEuler(new THREE.Euler(0, state.rotation.y, 0, 'YXZ'));

            const speed = state.speed * dt * 0.002;
            // WASD + Arrow keys for movement
            if (state.keys['KeyW'] || state.keys['ArrowUp']) state.velocity.addScaledVector(forward, speed);
            if (state.keys['KeyS'] || state.keys['ArrowDown']) state.velocity.addScaledVector(forward, -speed);
            if (state.keys['KeyA'] || state.keys['ArrowLeft']) state.velocity.addScaledVector(right, -speed);
            if (state.keys['KeyD'] || state.keys['ArrowRight']) state.velocity.addScaledVector(right, speed);

            state.position.add(state.velocity);
            state.velocity.multiplyScalar(state.friction);

            // Keep position within bounds (no padding - strict bounds)
            if (state.bounds) {
                state.position.x = Math.max(state.bounds.min_x, Math.min(state.bounds.max_x, state.position.x));
                state.position.y = Math.max(state.bounds.min_y, Math.min(state.bounds.max_y, state.position.y));
                state.position.z = Math.max(state.bounds.min_z, Math.min(state.bounds.max_z, state.position.z));
            }

            // Press R to reset to center
            if (state.keys['KeyR']) {
                resetToCenter();
                state.keys['KeyR'] = false; // Prevent repeated reset
            }

            // Rotate based on mouse position relative to center (only if mouse is in window)
            if (!state.modalOpen && mouseInWindow) {
                const centerX = window.innerWidth / 2;
                const centerY = window.innerHeight / 2;

                // Calculate offset from center (-1 to 1)
                const offsetX = (mouseX - centerX) / centerX;
                const offsetY = (mouseY - centerY) / centerY;

                // Dead zone in the middle (20% from center = no rotation)
                const deadZone = 0.2;

                // Apply rotation based on offset (with dead zone)
                if (Math.abs(offsetX) > deadZone) {
                    const strength = (Math.abs(offsetX) - deadZone) / (1 - deadZone);
                    const rotSpeed = strength * 0.0012 * dt * -Math.sign(offsetX);
                    state.rotation.y += rotSpeed;
                }
                if (Math.abs(offsetY) > deadZone) {
                    const strength = (Math.abs(offsetY) - deadZone) / (1 - deadZone);
                    const rotSpeed = strength * 0.0012 * dt * Math.sign(offsetY);
                    state.rotation.x -= rotSpeed;
                }

                // Clamp pitch to prevent gimbal lock
                state.rotation.x = Math.max(-Math.PI / 2.5, Math.min(Math.PI / 2.5, state.rotation.x));
            }

            camera.position.copy(state.position);
            camera.rotation.set(state.rotation.x, state.rotation.y, 0, 'YXZ');

            // Update HUD
            document.getElementById('position').textContent =
                `POSITION (${state.position.x.toFixed(1)}, ${state.position.y.toFixed(1)}, ${state.position.z.toFixed(1)})`;
            document.getElementById('speed-display').textContent = `SPEED: ${(state.speed * 1000).toFixed(0)}%`;
            document.getElementById('stars-count').textContent = `STARS: ${state.stars.length.toLocaleString()}`;

            // Preview update
            state.previewCooldown -= dt;
            if (state.previewCooldown <= 0) {
                const moved = !state.lastPreviewPos ||
                    state.position.distanceTo(state.lastPreviewPos) > 0.5;
                if (moved) {
                    updatePreview();
                    state.lastPreviewPos = state.position.clone();
                }
                state.previewCooldown = 200;
            }
        }

        async function updatePreview() {
            try {
                const x = state.position.x / SCALE;
                const y = state.position.y / SCALE;
                const z = state.position.z / SCALE;
                const res = await fetch(`/api/blend?x=${x}&y=${y}&z=${z}&k=5`);
                const data = await res.json();

                if (data.image) {
                    document.getElementById('preview-image').src = `data:image/png;base64,${data.image}`;
                }

                // Check if in the void (nearest star is far away)
                const voidWarning = document.getElementById('void-warning');
                if (data.neighbors && data.neighbors.length > 0) {
                    const nearestDist = data.neighbors[0].distance;
                    // Show warning if nearest star is more than 1.5 units away
                    if (nearestDist > 1.5) {
                        voidWarning.style.display = 'block';
                    } else {
                        voidWarning.style.display = 'none';
                    }
                }

                if (data.neighbors) {
                    document.getElementById('neighbors').innerHTML = data.neighbors.map(n =>
                        `<div class="neighbor">
                            <span class="neighbor-name">${n.name}</span>
                            <span class="neighbor-weight">${(n.weight * 100).toFixed(1)}%</span>
                        </div>`
                    ).join('');

                    updateActiveStars(data.neighbors);
                }
            } catch (e) {
                console.error('Preview error:', e);
            }
        }

        let lastTime = performance.now();
        function animate(time) {
            const dt = time - lastTime;
            lastTime = time;

            update(dt);
            updateLabels();
            updateProximityLabel();
            renderer.render(scene, camera);
            requestAnimationFrame(animate);
        }

        async function init() {
            const loadingStatus = document.getElementById('loading-status');
            const loadingProgress = document.getElementById('loading-progress');

            try {
                loadingStatus.textContent = 'LOADING BOUNDS...';
                loadingProgress.style.width = '10%';
                const boundsRes = await fetch('/api/bounds');
                state.bounds = await boundsRes.json();

                state.bounds.min_x *= SCALE;
                state.bounds.max_x *= SCALE;
                state.bounds.min_y *= SCALE;
                state.bounds.max_y *= SCALE;
                state.bounds.min_z *= SCALE;
                state.bounds.max_z *= SCALE;

                state.position.set(
                    (state.bounds.min_x + state.bounds.max_x) / 2,
                    (state.bounds.min_y + state.bounds.max_y) / 2,
                    (state.bounds.min_z + state.bounds.max_z) / 2
                );

                loadingStatus.textContent = 'LOADING STARS...';
                loadingProgress.style.width = '30%';
                const starsRes = await fetch('/api/all_stars');
                const starsData = await starsRes.json();
                state.stars = starsData.stars;

                loadingStatus.textContent = 'CREATING UNIVERSE...';
                loadingProgress.style.width = '70%';
                createStars(state.stars);
                createLabels();

                loadingStatus.textContent = 'READY';
                loadingProgress.style.width = '100%';

                setTimeout(() => {
                    document.getElementById('loading').style.display = 'none';
                    document.getElementById('top-bar').style.display = 'flex';
                    document.getElementById('ui-container').style.display = 'grid';

                    updatePreview();
                    requestAnimationFrame(animate);
                }, 500);

            } catch (e) {
                console.error('Init error:', e);
                loadingStatus.textContent = 'ERROR: ' + e.message;
            }
        }

        init();
    </script>
</body>
</html>
